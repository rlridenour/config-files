#+TITLE: Doom Emacs Configuration
#+AUTHOR: Randy Ridenour

This is my main configuration file for Doom Emacs.
* Personal information

#+begin_src emacs-lisp :tangle yes
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
(setq user-full-name "Randy Ridenour"
      user-mail-address "rlridenour@gmail.com")
#+end_src

* Appearance

** Initial Settings

Put autosave files (ie #foo#) and backup files (ie foo~) in ~/.emacs.d/.

#+begin_src emacs-lisp :tangle yes
(custom-set-variables
 '(auto-save-file-name-transforms '((".*" "~/.backups/emacs/autosaves/\\1" t)))
 '(backup-directory-alist '((".*" . "~/.backups/emacs/backups/"))))

;; create the autosave dir if necessary, since emacs won't.
(make-directory "~/.backups/emacs/autosaves/" t)
#+end_src

#+begin_src emacs-lisp :tangle yes
;; Set some misc defaults
(setq initial-major-mode 'org-mode
      initial-scratch-message nil
      make-pointer-invisible t
      display-time-24hr-format t
      display-time-day-and-date t)
#+end_src

** Font

#+begin_src emacs-lisp :tangle yes
(setq doom-font (font-spec :family "Input Mono" :size 16 :weight 'normal)
      doom-big-font (font-spec :family "Input Mono" :size 22 :weight 'normal)
      doom-variable-pitch-font (font-spec :family "Input Sans" :size 16 :weight 'normal))

(use-package! mixed-pitch
  :hook
  ;; If you want it in all text modes:
  (text-mode . mixed-pitch-mode))
#+end_src

** Cursor

#+begin_src emacs-lisp :tangle no
(setq evil-normal-state-cursor '(box "red2")
      evil-emacs-state-cursor '(box "blue4")
      evil-visual-state-cursor '(hollow "red2"))
#+end_src


** Initial screen size

I use  [[https://manytricks.com/moom/][Moom by Many Tricks]] to set window sizes on macOS. I always like them to be full-height, though.

#+begin_src emacs-lisp :tangle yes
(setq frame-resize-pixelwise t)
(add-to-list 'default-frame-alist '(fullscreen . fullheight))
#+end_src

** Theme

#+begin_src emacs-lisp :tangle yes
(setq doom-theme 'doom-homage-white)
#+end_src



When editing two files that have the same name, it's annoying to make changes in one thinking that it was the other. This helps to distinguish them by putting their path in the buffer name. Although both items are displayed in the menu bar, it's nice to be able to see the time and battery level in the mode-line. Finally, I always want to see matching parentheses and the current line highlighted.

#+begin_src emacs-lisp :tangle yes
;; (setq-default
 ;; uniquify-buffer-name-style 'forward)
;; (setq uniquify-buffer-name-style 'forward)
(display-time-mode 1)
(display-battery-mode 1)
(show-smartparens-global-mode t)
(global-visual-line-mode t)
#+end_src

This turns off Doom's highlighting for non-standard indentation. I've re-enabled it to see what I didn't like about it.


Don't ask for confirmation about running processes when killing Emacs.

#+begin_src emacs-lisp :tangle yes
(setq confirm-kill-processes nil)
#+end_src

Don't ask for confirmation when killing individual buffers, either.

#+begin_src emacs-lisp :tangle yes
(setq kill-buffer-query-functions nil)
#+end_src


Save buffers when losing focus:

#+begin_src emacs-lisp :tangle yes
(defun save-all ()
  (interactive)
  (save-some-buffers t))
(add-hook 'focus-out-hook 'save-all)
#+end_src

Auto-save every 20 characters.


#+begin_src emacs-lisp :tangle yes
(setq auto-save-interval 20)
#+end_src



Show normal vim mode indicators in the modeline.

#+begin_src emacs-lisp :tangle yes
(setq doom-modeline-modal-icon nil)
#+end_src

Pulsar to find current line.

#+begin_src emacs-lisp :tangle yes
(use-package! pulsar
  :custom
  (setq pulsar-pulse-functions
        '(isearch-repeat-forward
          isearch-repeat-backward
          recenter-top-bottom
          move-to-window-line-top-bottom
          reposition-window
          bookmark-jump
          other-window
          delete-window
          delete-other-windows
          forward-page
          backward-page
          scroll-up-command
          scroll-down-command
          windmove-right
          windmove-left
          windmove-up
          windmove-down
          windmove-swap-states-right
          windmove-swap-states-left
          windmove-swap-states-up
          windmove-swap-states-down
          tab-new
          tab-close
          tab-next
          org-next-visible-heading
          org-previous-visible-heading
          org-forward-heading-same-level
          org-backward-heading-same-level
          outline-backward-same-level
          outline-forward-same-level
          outline-next-visible-heading
          outline-previous-visible-heading
          outline-up-heading))
  :hook
  (consult-after-jump . pulsar-recenter-top)
  (consult-after-jump . pulsar-reveal-entry)
  ;; integration with the built-in `imenu':
  (imenu-after-jump . pulsar-recenter-top)
  (imenu-after-jump . pulsar-reveal-entry)
  :config
  (setq pulsar-pulse t
        pulsar-delay 0.2
        pulsar-iterations 10
        pulsar-face 'pulsar-blue
        pulsar-highlight-face 'pulsar-blue))

(pulsar-global-mode 1)

#+end_src


** Dashboard

#+begin_src emacs-lisp :tangle yes
(use-package dashboard
  :config
  (dashboard-setup-startup-hook)
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
  (setq doom-fallback-buffer-name "*dashboard*")
  (setq dashboard-week-agenda nil)
  (setq dashboard-startup-banner "/Users/rlridenour/.config/doom/logo-emacs.png")
  (setq dashboard-set-footer nil)
  (setq dashboard-banner-logo-title nil)
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons nil)
  (setq dashboard-set-navigator nil)
  (setq dashboard-items '((agenda . 5)
                          (recents  . 5)
                          (bookmarks . 10)
                          (projects . 5)))
  )
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun goto-dashboard ()
  "this sends you to the dashboard buffer"
  (interactive)
  (let ((goto-dashboard-buffer (get-buffer "*dashboard*")))
    (switch-to-buffer goto-dashboard-buffer))
  (dashboard-refresh-buffer))
#+end_src


** Windows

Ask which buffer to use after splitting a window.

#+begin_src emacs-lisp :tangle no
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src


** Zen mode

Don't make the text quite so large.

#+begin_src emacs-lisp :tangle yes
(setq +zen-text-scale 0.6)
#+end_src


Left-truncate recentf filenames. From [[https://github.com/minad/vertico/wiki][Home · minad/vertico Wiki · GitHub]]
#+begin_src emacs-lisp :tangle yes
(defun my/vertico-truncate-candidates (args)
  (if-let ((arg (car args))
           (type (get-text-property 0 'multi-category arg))
           ((eq (car-safe type) 'file))
           (w (max 30 (- (window-width) 38)))
           (l (length arg))
           ((> l w)))
      (setcar args (concat "…" (truncate-string-to-width arg l (- l w)))))
  args)
(advice-add #'vertico--format-candidate :filter-args #'my/vertico-truncate-candidates)
#+end_src

** Context menus

#+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook 'context-menu-mode)
(add-hook 'shell-mode-hook 'context-menu-mode)
(add-hook 'dired-mode-hook 'context-menu-mode)
#+end_src

* Basic editing

#+begin_src emacs-lisp :tangle yes
(load "~/Dropbox/emacs/my-emacs-abbrev")
#+end_src

Set  input method to TeX. This is especially useful for entering em and en-dashes. Turn it on with ~C-\~.

#+begin_src emacs-lisp :tangle yes
(setq default-input-method 'TeX)
#+end_src

Add my custom snippets to Yasnippet

#+begin_src emacs-lisp :tangle yes
(after! yasnippet
  (setq yas-snippet-dirs (append yas-snippet-dirs
                                 '("~/.config/doom/snippets"))))
#+end_src

Show number of isearch matches.

#+begin_src emacs-lisp :tangle yes
(setq-default isearch-lazy-count t)
#+end_src

Use evil-snipe for f, F, t, and T searches.

#+begin_src emacs-lisp :tangle no
;; Globally
(evil-snipe-override-mode 1)
(setq evil-snipe-spillover-scope 'visible)

(define-key evil-snipe-parent-transient-map (kbd "C-;")
  (evilem-create 'evil-snipe-repeat
                 :bind ((evil-snipe-scope 'buffer)
                        (evil-snipe-enable-highlight)
                        (evil-snipe-enable-incremental-highlight))))
#+end_src


Insert dates and times

#+begin_src emacs-lisp :tangle yes
(defun insert-date-string ()
  "Insert current date yyyymmdd."
  (interactive)
  (insert (format-time-string "%Y%m%d")))

(defun insert-standard-date ()
  "Inserts standard date time string."
  (interactive)
  (insert (format-time-string "%B %e, %Y")))
(global-set-key (kbd "<f8>") 'insert-standard-date)
(global-set-key (kbd "C-c d") 'insert-date-string)
#+end_src

** Spelling

#+begin_src emacs-lisp :tangle yes

;; (setq ispell-program-name "/opt/homebrew/bin/aspell")
;; (setq ispell-extra-args '("--sug-mode=ultra"))
(setq ispell-personal-dictionary "/Users/rlridenour/Dropbox/emacs/spelling/.aspell.en.pws")
(setq ispell-silently-savep t)
(global-set-key (kbd "<f7>") 'flyspell-correct-wrapper)
#+end_src



Use [[dictionary.org]] for dictionary search.

#+begin_src emacs-lisp :tangle yes
(setq dictionary-server "dict.org")
#+end_src

Correct last spelling error, from [[https://emacs.stackexchange.com/questions/54302/how-to-use-ispell-word-to-correct-a-word-immediately-without-prompting-for-multi][How to use ispell-word to correct a word immediately without prompting for mu...]]

#+begin_src emacs-lisp :tangle no
(defmacro ispell-word-immediate--with-messages-as-list (message-list &rest body)
  "Run BODY adding any message call to the MESSAGE-LIST list."
  (declare (indent 1))
  `
  (let ((temp-message-list (list)))
    (cl-letf
        (((symbol-function 'message)
          (lambda (&rest args)
            ;; Only check if non-null because this is a signal not to log at all.
            (when message-log-max
              (push (apply 'format-message args) temp-message-list)))))
      (unwind-protect
          (progn
            ,@body)
        ;; Protected.
        (setq ,message-list (append ,message-list (reverse temp-message-list)))))))

(defvar-local ispell-word-immediate--alist nil
  "Internal properties for repeated `ispell-word-immediate'")

(defun ispell-word-immediate--impl (cycle-direction)
  "Run `ispell-word', using the first suggestion.
Argument CYCLE-DIRECTION The offset for cycling words, 1 or -1 for forward/backward."
  (let ((message-list (list))
        (index 0)
        (point-init (point))
        (display-text nil))

    ;; Roll-back and cycle through corrections.
    (when
        (and
         ispell-word-immediate--alist
         (or
          (eq last-command 'ispell-word-immediate-forward)
          (eq last-command 'ispell-word-immediate-backward)))

      ;; Roll-back correction.
      (let ((alist ispell-word-immediate--alist))

        ;; Roll back the edit.
        (delete-region (alist-get 'start alist) (alist-get 'end alist))
        (insert (alist-get 'word alist))

        ;; Update vars from previous state.
        (setq point-init (alist-get 'point alist))
        (setq index (+ cycle-direction (cdr (assq 'index alist))))

        ;; Roll back the buffer state.
        (setq buffer-undo-list (alist-get 'buffer-undo-list alist))
        (setq pending-undo-list (alist-get 'pending-undo-list alist))
        (goto-char point-init)))

    ;; Clear every time, ensures stale data is never used.
    (setq ispell-word-immediate--alist nil)

    (cl-letf
        (((symbol-function 'ispell-command-loop)
          (lambda (miss _guess word start end)
            ;; Wrap around in either direction.
            (setq index (mod index (length miss)))
            (let ((word-at-index (nth index miss)))

              ;; Generate display text.
              (setq display-text
                    (string-join
                     (mapcar
                      (lambda (word-iter)
                        (if (eq word-at-index word-iter)
                            (format "[%s]" (propertize word-iter 'face 'match))
                          (format " %s " word-iter)))
                      miss)
                     ""))

              ;; Set the state for redoing the correction.
              (setq ispell-word-immediate--alist
                    (list
                     ;; Tricky! but nicer usability.
                     (cons 'buffer-undo-list buffer-undo-list)
                     (cons 'pending-undo-list pending-undo-list)
                     (cons 'point point-init)

                     (cons 'index index)
                     (cons 'word word)
                     (cons 'start (marker-position start))
                     (cons 'end
                           (+ (marker-position end)
                              (- (length word-at-index) (length word))))))

              word-at-index))))

      ;; Run quietly so message output doesn't flicker.
      (prog1 (ispell-word-immediate--with-messages-as-list message-list (ispell-word))

        ;; Log the message, only display if we don't have 'display-text'
        ;; This avoids flickering message output.
        (let ((inhibit-message (not (null display-text))))
          (dolist (message-text message-list)
            (message "%s" message-text)))

        ;; Run last so we can ensure it's the last text in the message buffer.
        ;; Don't log because it's not useful to keep the selection.
        (when display-text
          (let ((message-log-max nil))
            (message "%s" display-text)))))))

;; Public functions.
(defun ispell-word-immediate-forward ()
  "Run `ispell-word', using the first suggestion, or cycle forward."
  (interactive)
  (spell-fu-goto-previous-error)
  (ispell-word-immediate--impl 1))

(defun ispell-word-immediate-backward ()
  "Run `ispell-word', using the first suggestion, or cycle backward."
  (interactive)
  (ispell-word-immediate--impl -1))
#+end_src


** Scratch

Kill contents of scratch buffer, not the buffer itself. From [[http://emacswiki.org/emacs/RecreateScratchBuffer][TN]].

#+begin_src emacs-lisp :tangle yes
(defun unkillable-scratch-buffer ()
  (if (equal (buffer-name (current-buffer)) "*scratch*")
      (progn
        (delete-region (point-min) (point-max))
        nil)
    t))
(add-hook 'kill-buffer-query-functions 'unkillable-scratch-buffer)
#+end_src

Create a new scratch buffer if there isn't one, find it if there is.

#+begin_src emacs-lisp :tangle yes
(defun goto-scratch ()
  "this sends you to the scratch buffer"
  (interactive)
  (let ((goto-scratch-buffer (get-buffer-create "*scratch*")))
    (switch-to-buffer goto-scratch-buffer)
    (org-mode)))

(map! "M-g s" #'goto-scratch)
#+end_src


** Saved Keyboard Macros

Splits Org-mode list items

#+begin_src emacs-lisp :tangle yes
(fset 'split-org-item
      [?\C-k ?\M-\\ return ?\C-y])
#+end_src


#+begin_src emacs-lisp :tangle yes
(fset 'convert-markdown-to-org
      [?\M-< ?\M-% ?* return ?- return ?! ?\M-< ?\C-\M-% ?# ?* backspace backspace ?  ?# ?* ?$ return return ?! ?\M-< ?\M-% ?# return ?* return ?!])
#+end_src


** Bookmarks and Abbreviations

#+begin_src emacs-lisp :tangle yes

;; Load Abbreviations
(load "~/Dropbox/emacs/my-emacs-abbrev")

;; Bookmarks
(require 'bookmark)
(bookmark-bmenu-list)

#+end_src


** Evil Settings

#+begin_src emacs-lisp :tangle no
(use-package! evil
  :init
  (setq evil-disable-insert-state-bindings t
        evil-default-state 'insert
        ;;evil-undo-system 'undo-fu
        evil-cross-lines t
        evil-vsplit-window-right t
        evil-split-window-below t
        evil-respect-visual-line-mode t)
  :config
  (evil-set-initial-state 'dired-mode 'emacs)
  (evil-set-initial-state '+doom-dashboard-mode 'normal) 
  (evil-set-initial-state 'dashboard-mode 'normal) 
  (evil-set-initial-state 'calendar-mode 'emacs))

(define-key evil-visual-state-map (kbd "v") 'er/expand-region)
(defalias 'evil-insert-state 'evil-emacs-state)
(define-key evil-emacs-state-map (kbd "<escape>") 'evil-normal-state)
#+end_src


** Meow

#+begin_src emacs-lisp :tangle yes
(add-to-list 'meow-mode-state-list '(text-mode . insert))
(add-to-list 'meow-mode-state-list '(prog-mode . insert))
#+end_src


** Undo

#+begin_src emacs-lisp :tangle yes
;; Increase undo history limits even more
(after! undo-fu
  ;; Emacs undo defaults
  (setq undo-limit        10000000    ;; 1MB   (default is 160kB, Doom's default is 400kB)
        undo-strong-limit 100000000   ;; 100MB (default is 240kB, Doom's default is 3MB)
        undo-outer-limit  1000000000) ;; 1GB   (default is 24MB,  Doom's default is 48MB)

  ;; Undo-fu customization options
  (setq undo-fu-allow-undo-in-region t ;; Undoing with a selection will use undo within that region.
        undo-fu-ignore-keyboard-quit t)) ;; Use the `undo-fu-disable-checkpoint' command instead of Ctrl-G `keyboard-quit' for non-linear behavior.

;; Evil undo
;;(after! evil
;;  (setq evil-want-fine-undo t)) ;; By default while in insert all changes are one big blob
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! vundo
  :defer t
  :init
  (defconst +vundo-unicode-symbols
   '((selected-node   . ?●)
     (node            . ?○)
     (vertical-stem   . ?│)
     (branch          . ?├)
     (last-branch     . ?╰)
     (horizontal-stem . ?─)))

  (map! :leader
        (:prefix ("o")
         :desc "vundo" "v" #'vundo))

  :config
  (setq vundo-glyph-alist +vundo-unicode-symbols
        vundo-compact-display t
        vundo-window-max-height 6))
#+end_src

** Shell Command Buffers

Don't display async shell command process buffers. For some reason this is not working.

#+begin_src emacs-lisp :tangle no
(add-to-list 'display-buffer-alist '("^*Async Shell Command*" . (display-buffer-no-window)))
(add-to-list 'display-buffer-alist
  (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))
#+end_src

Make the async shell command process buffers small.

#+begin_src emacs-lisp :tangle no
(set-popup-rule! "*Async Shell Command*" :side 'bottom :size .1 :quit 'current)
#+end_src




* Dired

#+begin_src emacs-lisp :tangle yes
(use-package! dired-x
  :hook ((dired-mode . dired-omit-mode))
  :config
  (setq dired-omit-verbose nil)
  ;; hide backup, autosave, *.*~ files
  ;; omit mode can be toggled using `C-x M-o' in dired buffer.
  (setq-default dired-omit-extensions '("fdb_latexmk" "aux" "bbl" "blg" "fls" ".glo" "idx" "ilg" ".ind" "ist" ".log" ".out" "gz" "bcf" "run.xml" "toc" "DS_Store" "auctex-auto"))
  (setq dired-omit-files
        (concat dired-omit-files "\\|^.DS_STORE$\\|^.projectile$\\|^.git$\\|^\\..+$")))

(map! :map dired-mode-map
      :g "<M-return>" #'crux-open-with)

(setq dired-dwim-target t)

(use-package! dired-subtree
  :after dired
  :config
  (setq dired-subtree-use-backgrounds nil)
  (bind-key "<tab>" #'dired-subtree-toggle dired-mode-map)
  (bind-key "<backtab>" #'dired-subtree-cycle dired-mode-map))

#+end_src


From [[https://www.n16f.net/blog/decluttering-dired-for-peace-of-mind/][Brain dump – Decluttering Dired for peace of mind]]

#+begin_src emacs-lisp :tangle yes
(setq g-dired-minimal-view t)

(defun g-dired-setup-view ()
  (dired-hide-details-mode (if g-dired-minimal-view 1 -1)))

(defun g-dired-switch-view ()
  (interactive)
  (setq g-dired-minimal-view (not g-dired-minimal-view))
  (g-dired-setup-view))

(use-package dired
  :config
  (setq dired-hide-details-hide-symlink-targets nil)
  :hook
  ((dired-mode-hook . g-dired-setup-view))
  :bind
  (:map dired-mode-map
        ("<tab>" . g-dired-switch-view)))

(defun g-dired-postprocess-ls-output ()
  "Postprocess the list of files printed by the ls program when
executed by Dired."
  (save-excursion
    (goto-char (point-min))
    (while (not (eobp))
      ;; Go to the beginning of the next line representing a file
      (while (null (dired-get-filename nil t))
        (dired-next-line 1))
      (beginning-of-line)
      ;; Narrow to the line and process it
      (let ((start (line-beginning-position))
            (end (line-end-position)))
        (save-restriction
          (narrow-to-region start end)
          (setq inhibit-read-only t)
          (unwind-protect
              (g-dired-postprocess-ls-line)
            (setq inhibit-read-only nil))))
      ;; Next line
      (dired-next-line 1))))

(defun g-dired-disable-line-wrapping ()
  (setq truncate-lines t))

(defun g-dired-postprocess-ls-line ()
  "Postprocess a single line in the ls output, i.e. the information
about a single file. This function is called with the buffer
narrowed to the line."
  ;; Highlight everything but the filename
  (when (re-search-forward directory-listing-before-filename-regexp nil t 1)
    (add-text-properties (point-min) (match-end 0) '(font-lock-face shadow)))
  ;; Hide the link count
  (beginning-of-line)
  (when (re-search-forward " +[0-9]+" nil t 1)
    (add-text-properties (match-beginning 0) (match-end 0) '(invisible t))))

(use-package dired
  :config
  (setq dired-listing-switches "-alh --time-style=long-iso")
  :hook
  ((dired-mode-hook . g-dired-disable-line-wrapping)
   (dired-after-readin-hook . g-dired-postprocess-ls-output)))
#+end_src

** Dirvish

#+begin_src emacs-lisp :tangle no
;; This is *NECESSARY* for Doom users who enabled `dired' module
(map! :map dired-mode-map :ng "q" #'quit-window)
(use-package! dirvish
  :config
  (setq dirvish-hide-details t))

#+end_src


** Embark

#+begin_src emacs-lisp :tangle yes
(use-package! embark
:config
(define-key embark-heading-map "T" #'titlecase-line)
(define-key embark-region-map "T" #'titlecase-region))
#+end_src



* Extensions

** Which-Key 

#+begin_src emacs-lisp :tangle no
(after! which-key
(setq which-key-use-C-h-commands t))
#+end_src



** Evil

Some changes to Evil mode: 

1. Make substitution using ":s/.../..." global. 
2. Don't move the cursor back when going from insert to normal mode.
3. Don't send replaced text to the kill ring.
4. Use emacs keybindings in insert mode.

#+begin_src emacs-lisp :tangle no
(after! evil
  (setq evil-ex-substitute-global t    ; Make substition global by default.
        evil-move-cursor-back nil      ; Don't go back when turning normal mode on.
        evil-kill-on-visual-paste nil))  ; Don't send replaced text to the kill ring.
#+end_src

** Yasnippet

Add my custom snippets to Yasnippet

#+begin_src emacs-lisp :tangle no
(after! yasnippet
  (setq yas-snippet-dirs (append yas-snippet-dirs
                                 '("~/.config/doom/snippets"))))
#+end_src

** Tempel

#+begin_src emacs-lisp :tangle yes
;; Configure Tempel
(use-package tempel
  ;; Require trigger prefix before template name when completing.
  ;; :custom
  ;; (tempel-trigger-prefix "<")

  :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
         ("M-*" . tempel-insert))

  :init

  ;; Setup completion at point
  (defun tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions'.
    ;; `tempel-expand' only triggers on exact matches. Alternatively use
    ;; `tempel-complete' if you want to see all matches, but then you
    ;; should also configure `tempel-trigger-prefix', such that Tempel
    ;; does not trigger too often when you don't expect it. NOTE: We add
    ;; `tempel-expand' *before* the main programming mode Capf, such
    ;; that it will be tried first.
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))

  (add-hook 'prog-mode-hook 'tempel-setup-capf)
  (add-hook 'text-mode-hook 'tempel-setup-capf)

  ;; Optionally make the Tempel templates available to Abbrev,
  ;; either locally or globally. `expand-abbrev' is bound to C-x '.
  ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
  ;; (global-tempel-abbrev-mode)

:config
(setq tempel-path "~/.config/doom/templates.el")
)

;; Optional: Add tempel-collection.
;; The package is young and doesn't have comprehensive coverage.
;; (use-package tempel-collection)

;; Optional: Use the Corfu completion UI
(use-package corfu
  :init
  (global-corfu-mode))
#+end_src


** Corfu

#+begin_src emacs-lisp :tangle yes
;; Enable Corfu completion UI
;; See the Corfu README for more configuration tips.
(use-package corfu
  :init
  (global-corfu-mode))

;; Add extensions
(use-package cape
  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("C-c p p" . completion-at-point) ;; capf
         ("C-c p t" . complete-tag)        ;; etags
         ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
         ("C-c p h" . cape-history)
         ("C-c p f" . cape-file)
         ("C-c p k" . cape-keyword)
         ("C-c p s" . cape-symbol)
         ("C-c p a" . cape-abbrev)
         ("C-c p i" . cape-ispell)
         ("C-c p l" . cape-line)
         ("C-c p w" . cape-dict)
         ("C-c p \\" . cape-tex)
         ("C-c p _" . cape-tex)
         ("C-c p ^" . cape-tex)
         ("C-c p &" . cape-sgml)
         ("C-c p r" . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  ;;(add-to-list 'completion-at-point-functions #'cape-history)
  ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
  ;;(add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  ;;(add-to-list 'completion-at-point-functions #'cape-ispell)
  ;;(add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
)
#+end_src


** Auto-Activating Snippets

#+begin_src emacs-lisp :tangle yes
(use-package aas
:hook (LaTeX-mode . aas-activate-for-major-mode)
:hook (org-mode . aas-activate-for-major-mode)
:config
(aas-set-snippets 'text-mode
;; expand unconditionally
";o-" "ō"
";i-" "ī"
";a-" "ā"
";u-" "ū"
";e-" "ē")
(aas-set-snippets 'org-mode
"srcel" '(tempel "#+begin_src emacs-lisp :tangle yes" n q n "#+end_src")
)
(aas-set-snippets 'latex-mode
;; set condition!
:cond #'texmathp ; expand only while in math
".." "\\land"
">>" "\\lif"
"==" "\\liff"
"vv" "\\lor"
"~~" "\\lnot"
"EE" "\\exists"
"AA" "\\forall"
)
;; disable snippets by redefining them with a nil expansion
(aas-set-snippets 'latex-mode
";sn" '(tempel "\\section{" q "}")
";ssn" '(tempel "\\subsection{" q "}")
"supp" nil))
#+end_src

** Hungry Delete

Hungry delete deletes consecutive whitespace.

#+begin_src emacs-lisp :tangle yes
(use-package! hungry-delete
  :defer
  :config
  (global-hungry-delete-mode))
#+end_src

** Shrink Whitespace

The Shrink Whitespace package reduces all whitespace surrounding the point to one empty line or space when called once. When called again, it also eliminates that bit of whitespace.

#+begin_src emacs-lisp :tangle yes
(use-package! shrink-whitespace
  :defer)
(map! "M-=" #'shrink-whitespace)
#+end_src

** Company Mode

#+begin_src emacs-lisp :tangle no
(use-package! company
  :init
  (setq company-idle-delay 3
        company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil
        company-minimum-prefix-length 2
        company-show-numbers t)
  :config
  (add-hook 'after-init-hook 'global-company-mode)
  (add-hook 'after-init-hook 'company-tng-mode)
  (add-hook 'evil-normal-state-entry-hook #'company-abort))
#+end_src

** Corfu




** WS-Butler

#+begin_src emacs-lisp :tangle yes
(ws-butler-global-mode)
#+end_src

** MoveText

#+begin_src emacs-lisp :tangle yes
(use-package! move-text
  :config
  (map! "<M-S-up>" #'move-text-up)
  (map! "<M-S-down>" #'move-text-down))
#+end_src


** Fish Mode

#+begin_src emacs-lisp :tangle yes
(use-package! fish-mode)
#+end_src


** Dwim-shell-command

#+begin_src emacs-lisp :tangle yes
(use-package! dwim-shell-command)
#+end_src


** Deadgrep

#+begin_src emacs-lisp :tangle yes
(use-package! deadgrep
:config
(global-set-key (kbd "<f5>") #'deadgrep)
)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! yankpad
:init
  (setq yankpad-file "~/Library/Mobile Documents/com~apple~CloudDocs/org/yankpad.org")
:config
  (bind-key "<f6>" 'yankpad-insert))
#+end_src


** Titlecase

#+begin_src emacs-lisp :tangle yes
(use-package! titlecase
:config
(setq titlecase-style "chicago"))
#+end_src


* Functions

Helper function to suppress the output window of asynchronous shell commands. From [[https://dotdoom.rgoswami.me/config.html][Literate doom-emacs config]].

#+begin_src emacs-lisp :tangle yes
(defun async-shell-command-no-window
    (command)
  (interactive)
  (let
      ((display-buffer-alist
        (list
         (cons
          "\\*Async Shell Command\\*.*"
          (cons #'display-buffer-no-window nil)))))
    (async-shell-command
     command)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun delete-window-balance ()
  "Delete window and rebalance the remaining ones."
  (interactive)
  (delete-window)
  (balance-windows))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun split-window-below-focus ()
  "Split window horizontally and move focus to other window."
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun split-window-right-focus ()
  "Split window vertically and move focus to other window."
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun rlr/find-file-right ()
  "Split window vertically and select recent file."
  (interactive)
  (split-window-right-focus)
  (consult-buffer))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun rlr/find-file-below ()
  "Split window horizontally and select recent file."
  (interactive)
  (split-window-below-focus)
  (consult-buffer))
#+end_src

;; Fullscreen

#+begin_src emacs-lisp :tangle yes
(defun toggle-frame-maximized-undecorated () (interactive) (let* ((frame (selected-frame)) (on? (and (frame-parameter frame 'undecorated) (eq (frame-parameter frame 'fullscreen) 'maximized))) (geom (frame-monitor-attribute 'geometry)) (x (nth 0 geom)) (y (nth 1 geom)) (display-height (nth 3 geom)) (display-width (nth 2 geom)) (cut (if on? (if ns-auto-hide-menu-bar 26 50) (if ns-auto-hide-menu-bar 4 26)))) (set-frame-position frame x y) (set-frame-parameter frame 'fullscreen-restore 'maximized) (set-frame-parameter nil 'fullscreen 'maximized) (set-frame-parameter frame 'undecorated (not on?)) (set-frame-height frame (- display-height cut) nil t) (set-frame-width frame (- display-width 20) nil t) (set-frame-position frame x y)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun insert-date-string ()
  "Insert current date yyyymmdd."
  (interactive)
  (insert (format-time-string "%Y%m%d")))
#+end_src
#+begin_src emacs-lisp :tangle yes
(defun insert-standard-date ()
  "Inserts standard date time string."
  (interactive)
  (insert (format-time-string "%B %e, %Y")))
(global-set-key (kbd "<f8>") 'insert-standard-date)
(global-set-key (kbd "C-c d") 'insert-date-string)
#+end_src

#+begin_src emacs-lisp :tangle yes
;; Open files in dired mode using 'open' in OS X
(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map (kbd "z")
       (lambda () (interactive)
         (let ((fn (dired-get-file-for-visit)))
           (start-process "default-app" nil "open" fn))))))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun rlr-count-words (&optional begin end)
  "count words between BEGIN and END (region); if no region defined, count words in buffer"
  (interactive "r")
  (let ((b (if mark-active begin (point-min)))
        (e (if mark-active end (point-max))))
    (message "Word count: %s" (how-many "\\w+" b e))))
#+end_src


#+begin_src emacs-lisp :tangle yes
(defun transpose-windows ()
  "Transpose two windows.  If more or less than two windows are visible, error."
  (interactive)
  (unless (= 2 (count-windows))
    (error "There are not 2 windows."))
  (let* ((windows (window-list))
         (w1 (car windows))
         (w2 (nth 1 windows))
         (w1b (window-buffer w1))
         (w2b (window-buffer w2)))
    (set-window-buffer w1 w2b)
    (set-window-buffer w2 w1b)))
#+end_src


#+begin_src emacs-lisp :tangle yes
(defun occur-non-ascii ()
  "Find any non-ascii characters in the current buffer."
  (interactive)
  (occur "[^[:ascii:]]"))
#+end_src

#+begin_src emacs-lisp :tangle yes
;; From https://github.com/ocodo/.emacs.d/blob/master/custom/handy-functions.el
(defun nuke-all-buffers ()
  "Kill all the open buffers except the current one.
  Leave *scratch*, *dashboard* and *Messages* alone too."
  (interactive)
  (mapc
   (lambda (buffer)
     (unless (or
              (string= (buffer-name buffer) "*scratch*")
              (string= (buffer-name buffer) "*dashboard*")
              (string= (buffer-name buffer) "*Messages*"))
       (kill-buffer buffer)))
   (buffer-list))
  (delete-other-windows))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun make-parent-directory ()
  "Make sure the directory of `buffer-file-name' exists."
  (make-directory (file-name-directory buffer-file-name) t))
(add-hook 'find-file-not-found-functions #'make-parent-directory)
#+end_src

;; Fill functions from https://schauderbasis.de/posts/reformat_paragraph/

#+begin_src emacs-lisp :tangle yes
(use-package! unfill)

(defun fill-sentences-in-paragraph ()
  "Put a newline at the end of each sentence in the current paragraph."
  (interactive)
  (save-excursion
    (mark-paragraph)
    (call-interactively 'fill-sentences-in-region)
    )
  )

(defun fill-sentences-in-region (start end)
  "Put a newline at the end of each sentence in the region maked by (start end)."
  (interactive "*r")
  (call-interactively 'unfill-region)
  (save-excursion
    (goto-char start)
    (while (< (point) end)
      (forward-sentence)
      (if (looking-at-p " ")
          (newline-and-indent)
        )
      )
    )
  )

(defvar repetition-counter 0
  "How often cycle-on-repetition was called in a row using the same command.")

(defun cycle-on-repetition (list-of-expressions)
  "Return the first element from the list on the first call,
   the second expression on the second consecutive call etc"
  (interactive)
  (if (equal this-command last-command)
      (setq repetition-counter (+ repetition-counter 1)) ;; then
    (setq repetition-counter 0) ;; else
    )
  (nth
   (mod repetition-counter (length list-of-expressions))
   list-of-expressions) ;; implicit return of the last evaluated value
  )

(defun reformat-paragraph ()
  "Cycles the paragraph between three states: filled/unfilled/fill-sentences."
  (interactive)
  (funcall (cycle-on-repetition '(fill-paragraph fill-sentences-in-paragraph unfill-paragraph)))
  )
#+end_src


Move lines, from [[https://emacsredux.com/blog/2013/04/02/move-current-line-up-or-down/][Bozhidar Batsov]]

#+begin_src emacs-lisp :tangle yes
(defun move-line-up ()
  "Move up the current line."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))

(defun move-line-down ()
  "Move down the current line."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))
#+end_src


* Languages

** BibTeX

#+begin_src emacs-lisp :tangle yes
(use-package! citar
  :bind (("C-c C-b" . citar-insert-citation)
         :map minibuffer-local-map
         ("M-b" . citar-insert-preset))
  :custom
  (org-cite-global-bibliography '("~/Dropbox/bibtex/rlr.bib"))
  (citar-bibliography '("~/Dropbox/bibtex/rlr.bib"))
  (org-cite-csl-styles-dir "/usr/local/texlive/2022/texmf-dist/tex/latex/citation-style-language/styles"))
#+end_src

Use ebib for bibtex file management

#+begin_src emacs-lisp :tangle yes
(use-package! ebib
  :defer
  :config
  (setq ebib-bibtex-dialect 'biblatex)
  ;;(evil-set-initial-state 'ebib-index-mode 'emacs)
  ;;(evil-set-initial-state 'ebib-entry-mode 'emacs)
  ;;(evil-set-initial-state 'ebib-log-mode 'emacs)
  :custom
  (ebib-preload-bib-files '("~/Dropbox/bibtex/rlr.bib")))
#+end_src

** Org Mode

Set org directory, along with a few org mode settings.

#+begin_src emacs-lisp :tangle yes
(use-package! org
  :init
  ;; (setq org-directory "/Users/rlridenour/Library/Mobile Documents/com~apple~CloudDocs/org/")
  (setq org-directory "/Users/rlridenour/Library/Mobile Documents/com~apple~CloudDocs/org/")
  :config
  (setq org-highlight-latex-and-related '(latex script entities))
  (setq org-startup-indented nil)
  (setq org-adapt-indentation nil)
  (setq org-hide-leading-stars nil)
  ;; (setq org-footnote-section nil)
  (setq org-html-validation-link nil)
  (setq org-todo-keyword-faces
        '(("DONE" . "green4")))
  (setq org-agenda-files '("/Users/rlridenour/Library/Mobile Documents/iCloud~com~appsonthemove~beorg/Documents/org/")))

;; (add-hook 'org-agenda-mode-hook #'turn-off-evil-mode nil)

;; (add-hook 'org-mode-hook 'variable-pitch-mode)
;; (set-face-attribute 'org-table nil :inherit 'doom-font)
#+end_src

Org-tempo is need for structure templates like "<s".

#+begin_src emacs-lisp :tangle yes
(require 'org-tempo)
#+end_src

I need to keep whitespace at the end of lines for my Beamer slides.

#+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook 'doom-disable-delete-trailing-whitespace-h)
#+end_src


#+begin_src emacs-lisp :tangle yes
;; Return adds new heading or list item. From https://github.com/aaronjensen/emacs-orgonomic
(use-package! orgonomic
  :defer t
  :hook (org-mode . orgonomic-mode)
  :bind (
         :map orgonomic-mode-map
         ("<S-s-return>" . orgonomic-shift-return)
         ("<S-return>" . crux-smart-open-line)))
#+end_src

Insert Org headings at point.

#+begin_src emacs-lisp :tangle yes
(after! org (setq org-insert-heading-respect-content nil))
#+end_src

Some export settings.

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
               '("org-article"
                 "\\documentclass{article}
      [NO-DEFAULT-PACKAGES]
      [NO-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("org-handout"
                 "\\documentclass{pdfhandout}
      [NO-DEFAULT-PACKAGES]
      [NO-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("org-beamer"
                 "\\documentclass{beamer}
      [NO-DEFAULT-PACKAGES]
      [NO-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  )

(setq org-export-with-smart-quotes t)

(with-eval-after-load 'ox-latex
  (add-to-list 'org-export-smart-quotes-alist 
               '("en-us"
                 (primary-opening   :utf-8 "“" :html "&ldquo;" :latex "\\enquote{"  :texinfo "``")
                 (primary-closing   :utf-8 "”" :html "&rdquo;" :latex "}"           :texinfo "''")
                 (secondary-opening :utf-8 "‘" :html "&lsquo;" :latex "\\enquote*{" :texinfo "`")
                 (secondary-closing :utf-8 "’" :html "&rsquo;" :latex "}"           :texinfo "'")
                 (apostrophe        :utf-8 "’" :html "&rsquo;")))

  )
#+end_src

Ignore LaTeX when spell checking

#+begin_src emacs-lisp :tangle yes
(defun flyspell-ignore-tex ()
  (interactive)
  (set (make-variable-buffer-local 'ispell-parser) 'tex))
(add-hook 'org-mode-hook (lambda () (setq ispell-parser 'tex)))
(add-hook 'org-mode-hook 'flyspell-ignore-tex)
#+end_src

Some functions for automating lecture notes and slides.


#+begin_src emacs-lisp :tangle yes

(defun  
    arara-slides ()
  ;; (interactive)
  (async-shell-command-no-window "mkslides"))

(defun  
    arara-notes ()
  ;; (interactive)
  (async-shell-command-no-window "mknotes"))


(defun lecture-slides ()
  "publish org data file as beamer slides"
  (interactive)
  (find-file "*-slides.org" t)
  (org-beamer-export-to-latex)
  (kill-buffer)
  (arara-slides)
  (find-file "*-data.org" t))


(defun lecture-notes ()
  "publish org data file as beamer notes"
  (interactive)
  (find-file "*-notes.org" t)
  (org-beamer-export-to-latex)
  (kill-buffer)
  (arara-notes)
  (find-file "*-data.org" t))

(defun present ()
  (interactive)
  (async-shell-command "present"))

(defun canvas-copy ()
  "Copy html for canvas pages"
  (interactive)
  (org-html-export-to-html)
  (shell-command "canvas")
  )

(setq org-latex-pdf-process '("arara %f"))

(defun rlr/dwim-mkt ()
  "Run arara and open PDF."
  (interactive)
  (dwim-shell-command-on-marked-files
   "Compile with arara"
   "mkt <<f>>"
   :silent-success t
   )
  )
(defun rlr/org-mkt ()
  "Make PDF with Arara."
  (interactive)
  (org-latex-export-to-latex)
  (async-shell-command-no-window (concat "mkt " (shell-quote-argument(file-name-sans-extension (buffer-file-name)))".tex")))

(defun rlr/dwim-org-mkt ()
  "Make PDF with Arara."
  (interactive)
  (org-latex-export-to-latex)
  (dwim-shell-command-on-marked-files
   "Compile with arara"
   "mkt <<fne>>.tex"
   :silent-success t
   )
  )


(defun rlr/org-mktc ()
  "Compile continuously with arara."
  (interactive)
  (org-latex-export-to-latex)
  (start-process-shell-command (concat "mktc-" (buffer-file-name)) (concat "mktc-" (buffer-file-name)) (concat "mktc " (shell-quote-argument(file-name-sans-extension (buffer-file-name)))".tex")))
#+end_src

*** Org capture

#+begin_src emacs-lisp :tangle yes
(setq org-capture-templates
      '(
        ("t" "Todo" entry (file+headline "/Users/rlridenour/Library/Mobile Documents/iCloud~com~appsonthemove~beorg/Documents/org/tasks.org" "Inbox")
         "** TODO %?\n  %i\n  %a")
        ("b" "Bookmark" entry (file+headline "/Users/rlridenour/Library/Mobile Documents/com~apple~CloudDocs/org/bookmarks.org" "Bookmarks")
         "* %?\n:PROPERTIES:\n:CREATED: %U\n:END:\n\n" :empty-lines 1)
        )
      )
(setq org-refile-targets '((org-agenda-files :maxlevel . 1)))

(define-key global-map "\C-cc" 'org-capture)
#+end_src


*** Org Super Agenda

From [[https://www.rousette.org.uk/archives/doom-emacs-tweaks-org-journal-and-org-super-agenda/][BSAG » Doom Emacs tweaks: Org Journal and Super Agenda]]

#+begin_src emacs-lisp :tangle yes
(use-package! org-super-agenda
  :after org-agenda
  :init
  (setq org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done t
        org-agenda-include-deadlines t
        org-agenda-block-separator nil
        org-agenda-compact-blocks t
        org-agenda-start-day nil ;; i.e. today
        org-agenda-span 1
        org-agenda-start-on-weekday nil)
  (setq org-agenda-custom-commands
        '(("c" "Super view"
           ((agenda "" ((org-agenda-overriding-header "")
                        (org-super-agenda-groups
                         '((:name "Today"
                            :time-grid t
                            :date today
                            :order 1)))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-super-agenda-groups
                          '((:log t)
                            (:name "Important"
                             :priority "A"
                             :order 4)
                            (:name "Today's tasks"
                             :file-path "journal/")
                            (:name "Due Today"
                             :deadline today
                             :order 2)
                            (:name "Overdue"
                             :deadline past
                             :order 3)
                            (:discard (:not (:todo "TODO")))))))))))
  :config
  (org-super-agenda-mode))
#+end_src

Display 7 full days in the agenda.

#+begin_src emacs-lisp :tangle yes
(setq org-agenda-span 7)
#+end_src


*** Deft
Use Deft for quick notes.

#+begin_src emacs-lisp :tangle no
(use-package! deft
  :after org
  :bind
  ;; ("C-c n d" . deft)
  :custom
  (deft-recursive t)
  (deft-use-filename-as-title nil)
  (deft-use-filter-string-for-filename t)
  (deft-extensions '("org" "md" "txt"))
  (deft-file-naming-rules '((noslash . "-")
                            (nospace . "-")
                            (case-fn . downcase)))
  (deft-default-extension "org")
  (deft-directory "/Users/rlridenour/Library/Mobile Documents/com~apple~CloudDocs/org/notes/"))
#+end_src


*** Denote

#+begin_src emacs-lisp :tangle yes
(use-package! denote
  :config
  (setq denote-directory "/Users/rlridenour/Library/Mobile Documents/com~apple~CloudDocs/Documents/notes")
  (setq denote-infer-keywords t)
  (setq denote-sort-keywords t)
  (setq denote-prompts '(title keywords))
  (setq denote-date-format nil)
  )

(use-package! consult-notes
  :config
  (setq consult-notes-sources
        `(("Notes"  ?n ,denote-directory)
          ;; ("Books"  ?b "~/Documents/books")
          )
        )
  )

(defun my-denote-journal ()
  "Create an entry tagged 'journal' with the date as its title."
  (interactive)
  (denote
   (format-time-string "%A %B %d %Y") ; format like Tuesday June 14 2022
   '("journal"))) ; multiple keywords are a list of strings: '("one" "two")


(use-package! citar-denote
  :after citar denote
  :config
  (citar-denote-mode)
  (setq citar-open-always-create-notes t))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! denote-menu)
#+end_src


*** EKG

#+begin_src emacs-lisp :tangle no
(use-package! emacsql)
#+end_src



#+begin_src emacs-lisp :tangle no
(use-package ekg
  :bind (([f9] . ekg-capture))
:init
(setq ekg-db-file "/Users/rlridenour/Library/Mobile Documents/com~apple~CloudDocs/org/.ekg/ekg.db"))
#+end_src


*** Org Roam


#+begin_src emacs-lisp :tangle no
(setq org-roam-dailies-directory "daily/")

(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         "* %?"
         :if-new (file+head "%<%Y-%m-%d>.org"
                            "#+title: %<%Y-%m-%d>\n"))))
#+end_src


#+begin_src emacs-lisp :tangle yes
(defun rlr/org-date ()
  "Update existing date: timestamp on a Hugo post."
  (interactive)
  (save-excursion (
                   goto-char 1)
                  (re-search-forward "^#\\+date:")
                  (let ((beg (point)))
                    (end-of-line)
                    (delete-region beg (point)))
                  (insert (concat " " (format-time-string "%B %e, %Y")))))
#+end_src

*** Hyperbole

#+begin_src emacs-lisp :tangle no
(use-package! hyperbole
  :bind
  ("C-c C-/" . hui-search-web)  ;; bind before calling require
  :custom-face
  (hbut       ((t (:foreground "green yellow"))))
  (hbut-flash ((t (:foreground "dark gray" :background "green yellow"))))
:config
  (setq hbmap:dir-user "/Users/rlridenour/Library/Mobile Documents/com~apple~CloudDocs/org")
  (setq hbmap:filename "personal-buttons.hypb")
  (setq hyrolo-file-list '("~/Library/Mobile Documents/com~apple~CloudDocs/org/notes.org"))
  (setq hyrolo-date-format "%Y-%m-%d %H:%M:%S")
)
#+end_src

 




*** Keybindings

#+begin_src emacs-lisp :tangle no
(map! :map evil-org-mode-map
      :after evil-org
      :i "<return>" #'orgonomic-return ; Make return automatically create new headings and list items.
      )
#+end_src

** LaTeX

#+begin_src emacs-lisp :tangle yes
;; use Skim as default pdf viewer
;; Skim's displayline is used for forward search (from .tex to .pdf)
;; option -b highlights the current line; option -g opens Skim in the background  
(after! tex
(setq TeX-view-program-selection '((output-pdf "PDF Viewer")))
(setq TeX-view-program-list
     '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b"))))
#+end_src




#+begin_src emacs-lisp :tangle yes
(use-package! cdlatex
  :defer
  :init
  (setq cdlatex-math-symbol-alist
        '((?. ("\\land" "\\cdot"))
          (?v ("\\lor" "\\vee"))
          (?> ("\\lif" "\\rightarrow"))
          (?= ("\\liff" "\\Leftrightarrow" "\\Longleftrightarrow"))
          (?! ("\\lneg" "\\neg"))
          (?# ("\\Box"))
          (?$ ("\\Diamond"))
          ))
  :config
  ;; (add-hook 'LaTeX-mode-hook #'turn-on-cdlatex)
  ;; (add-hook 'org-mode-hook #'turn-on-org-cdlatex)
  )

(map! :map cdlatex-mode-map :i "TAB" #'cdlatex-tab)
(map! :map cdlatex-mode-map :e "TAB" #'cdlatex-tab)

#+end_src

[[https://github.com/oantolin/math-delimiters][Math-delimiters]]

#+begin_src emacs-lisp :tangle yes
(autoload 'math-delimiters-insert "math-delimiters")

(with-eval-after-load 'org
  (define-key org-mode-map "$" #'math-delimiters-insert))

(with-eval-after-load 'tex              ; for AUCTeX
  (define-key TeX-mode-map "$" #'math-delimiters-insert))

(with-eval-after-load 'tex-mode         ; for the built-in TeX/LaTeX modes
  (define-key tex-mode-map "$" #'math-delimiters-insert))

(with-eval-after-load 'cdlatex
  (define-key cdlatex-mode-map "$" nil))
#+end_src





Functions for cleaning and compiling with Arara.

#+begin_src emacs-lisp :tangle yes
(defun tex-clean ()
  (interactive)
  (shell-command "latexmk -c"))


(defun tex-clean-all ()
  (interactive)
  (shell-command "latexmk -C"))

(eval-after-load "tex"
  '(add-to-list 'TeX-command-list
    '("Arara" "arara --verbose %s" TeX-run-TeX nil t :help "Run Arara.")))

(defun  
    arara-all ()
  (interactive)
  (async-shell-command "mkall"))

;; Run once

;; (defun rlr/tex-mkt ()
;;   "Compile with arara."
;;   (interactive)
;;   (async-shell-command-no-window (concat "mkt " (shell-quote-argument(buffer-file-name)))))

(defun rlr/tex-mkt ()
  "Compile with arara."
  (interactive)
(save-buffer)
  (shell-command (concat "mkt " (shell-quote-argument(buffer-file-name))))
(TeX-view))



;; Run continuously

(defun rlr/tex-mktc ()
  "Compile continuously with arara."
  (interactive)
  (async-shell-command-no-window (concat "mktc " (shell-quote-argument(buffer-file-name))))
)

;;   (TeX-view))


(defun latex-word-count ()
  (interactive)
  (let* ((this-file (buffer-file-name))
         (word-count
          (with-output-to-string
            (with-current-buffer standard-output
              (call-process "texcount" nil t nil "-brief" this-file)))))
    (string-match "\n$" word-count)
    (message (replace-match "" nil nil word-count))))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! latex-change-env
  :after latex
  :bind 
  (:map LaTeX-mode-map ("C-c r" . latex-change-env))
  ;; (:map LaTeX-mode-map ("s-<return>" . LaTeX-insert-item))
  :config
  (setq latex-change-env-display math-delimiters-display))
#+end_src

** Markdown

#+begin_src emacs-lisp :tangle no
(use-package! markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.Rmd\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :config
  (setq markdown-indent-on-enter 'indent-and-new-item)
  (setq markdown-asymmetric-header t))

#+end_src

* Hugo

This updates the time stamp on a Hugo post.

#+begin_src emacs-lisp :tangle yes

(defun hugo-timestamp ()
  "Update existing date: timestamp on a Hugo post."
  (interactive)
  (save-excursion (
                   goto-char 1)
                  (re-search-forward "^#\\+date:")
                  (let ((beg (point)))
                    (end-of-line)
                    (delete-region beg (point)))
                  (insert (concat " " (format-time-string "%Y-%m-%dT%H:%M:%S")))))
#+end_src

Set a few variables and some utility functions that are used later.

#+begin_src emacs-lisp :tangle yes
(defvar hugo-directory "~/Sites/blog/" "Path to Hugo blog.")
(defvar hugo-posts-dir "content/posts/" "Relative path to posts directory.")
(defvar hugo-post-ext ".org"  "File extension of Hugo posts.")
(defvar hugo-post-template "#+TITLE: \%s\n#+draft: true\n#+tags[]: \n#+date: \n#+lastmod: \n#+mathjax: \n\n"
  "Default template for Hugo posts. %s will be replace by the post title.")

(defun hugo-make-slug (s) "Turn a string into a slug."
       (replace-regexp-in-string " " "-"  (downcase (replace-regexp-in-string "[^A-Za-z0-9 ]" "" s))))

(defun hugo-yaml-escape (s) "Escape a string for YAML."
       (if (or (string-match ":" s) (string-match "\"" s)) (concat "\"" (replace-regexp-in-string "\"" "\\\\\"" s) "\"") s))
#+end_src

Create a new blog post.

#+begin_src emacs-lisp :tangle yes
(defun hugo-draft-post (title) "Create a new Hugo blog post."
       (interactive "sPost Title: ")
       (let ((draft-file (concat hugo-directory hugo-posts-dir
                                 (format-time-string "%Y-%m-%d-")
                                 (hugo-make-slug title)
                                 hugo-post-ext)))
         (if (file-exists-p draft-file)
             (find-file draft-file)
           (find-file draft-file)
           (insert (format hugo-post-template (hugo-yaml-escape title)))
           (hugo-timestamp))))
#+end_src

This sets the draft tag to false, updates the timestamp, and saves the buffer.

#+begin_src emacs-lisp :tangle yes
(defun hugo-publish-post ()
  "Set draft to false, update the timestamp, and save."
  (interactive)
  (save-excursion 
                   (goto-char 1)
                  (re-search-forward "^#\\+draft:")
                  (let ((beg (point)))
                    (end-of-line)
                    (delete-region beg (point)))
                  (insert " false")
                  (hugo-timestamp))
  (save-buffer))

(defmacro with-dir (DIR &rest FORMS)
  "Execute FORMS in DIR."
  (let ((orig-dir (gensym)))
    `(progn (setq ,orig-dir default-directory)
            (cd ,DIR) ,@FORMS (cd ,orig-dir))))
#+end_src

Update the last modified date.

#+begin_src emacs-lisp :tangle yes
(defun hugo-update-lastmod ()
  "Update the `lastmod' value for a hugo org-mode buffer."
  (interactive)
  (save-excursion
    (goto-char 1)
    (re-search-forward "^#\\+lastmod:")
    (let ((beg (point)))
      (end-of-line)
      (delete-region beg (point)))
    (insert (concat " " (format-time-string "%Y-%m-%dT%H:%M:%S"))))
  (save-buffer))
#+end_src

Deploy the blog.

#+begin_src emacs-lisp :tangle yes
(defun hugo-deploy ()
  "Push changes upstream."
  (interactive)
  (with-dir hugo-directory
            (shell-command "git add .")
            (--> (current-time-string)
                 (concat "git commit -m \"" it "\"")
                 (shell-command it))
            (magit-push-current-to-upstream nil)))
#+end_src

Update the last modified date of a post, save the buffer, and deploy.

#+begin_src emacs-lisp :tangle yes
(defun hugo-org-deploy ()
  "Push changes upstream."
  (interactive)
  (hugo-update-lastmod)
  (save-buffer)
  (with-dir hugo-directory
            (shell-command "git add .")
            (--> (current-time-string)
                 (concat "git commit -m \"" it "\"")
                 (shell-command it))
            (magit-push-current-to-upstream nil)))
#+end_src
Insert a tag into a Hugo post. From [[https://whatacold.io/blog/2022-10-10-emacs-hugo-blogging/][Hugo Blogging in Emacs - whatacold's space]] 

#+begin_src emacs-lisp :tangle yes
(defun hugo-select-tags ()
  "Select tags from the hugo org files in the current dir.

Note that it only extracts tags from lines like the below:
,#+tags[]: Emacs Org-mode"
  (interactive)
  ;; Move to end of tag line.
  (save-excursion
    (goto-char 1)
    (re-search-forward "^#\\+tags")
    (end-of-line)

    (let ((files (directory-files-recursively default-directory "\\.org$")))
      (let ((source (with-temp-buffer
                      (while files
                        (when (file-exists-p (car files))
                          (insert-file-contents (car files)))
                        (pop files))
                      (buffer-string))))
        (save-match-data
          (let ((pos 0)
                matches)
            (while (string-match "^#\\+[Tt]ags\\[\\]: \\(.+?\\)$" source pos)
              (push (match-string 1 source) matches)
              (setq pos (match-end 0)))
            (insert
             (completing-read
              "Insert a tag: "
              (sort
               (delete-dups
                (delete "" (split-string
                            (replace-regexp-in-string "[\"\']" " "
                                                      (replace-regexp-in-string
                                                       "[,()]" ""
                                                       (format "%s" matches)))
                            " ")))
               (lambda (a b)
                 (string< (downcase a) (downcase b))))))))))
    (insert " ")
    )
  )
#+end_src

Add multiple tags to a Hugo post. I need to try to make it work with consult--read.

#+begin_src emacs-lisp :tangle no
(defun w/hugo--collect-tags ()
  "Collect hugo tags from the org files in the current dir.

Note that it only extracts tags from lines like the below:
#+tags[]: Emacs Org-mode"
  (interactive)
  (let ((files (directory-files-recursively default-directory "\\.org$")))
    (let ((source (with-temp-buffer
		    (while files
                      (when (file-exists-p (car files))
                        (insert-file-contents (car files)))
		      (pop files))
		    (buffer-string))))
      (save-match-data
	(let ((pos 0)
	      matches)
	  (while (string-match "^#\\+[Tt]ags\\[\\]: \\(.+?\\)$" source pos)
	    (push (match-string 1 source) matches)
	    (setq pos (match-end 0)))
          (sort
	   (delete-dups
	    (delete "" (split-string
			(replace-regexp-in-string "[\"\']" " "
						  (replace-regexp-in-string
						   "[,()]" ""
						   (format "%s" matches)))
			" ")))
           (lambda (a b)
             (string< (downcase a) (downcase b)))))))))

(defun w/hugo-select-tags ()
  "Select tags for the current hugo post."
  (interactive)
  (ivy-read "Insert tags: "
            (w/hugo--collect-tags)
            :action
            (lambda (tag)
              (insert (if (char-equal (preceding-char) 32)
                          ""
                        " ")
                      tag))))
#+end_src

Insert internal links using C-c C-l. From [[https://lucidmanager.org/productivity/create-websites-with-org-mode-and-hugo/][Create Websites with Emacs: Blogging with Org mode and Hugo]]

#+begin_src emacs-lisp :tangle yes
;; Follow Hugo links
  (defun org-hugo-follow (link)
    "Follow Hugo link shortcodes"
    (org-link-open-as-file
     (string-trim "{{< ref test.org >}}" "{{< ref " ">}}")))

  ;; New link type for Org-Hugo internal links
  (org-link-set-parameters
   "hugo"
   :complete (lambda ()
               (concat "{{< ref "
                       (file-name-nondirectory
                        (read-file-name "File: "))
                       " >}}"))
   :follow #'org-hugo-follow)
#+end_src


Set some keybindings for the Hugo functions.


#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c h n") 'hugo-draft-post)
(global-set-key (kbd "C-c h p") 'hugo-publish-post)
(global-set-key (kbd "C-c h t") 'hugo-timestamp)
(global-set-key (kbd "C-c h O") (lambda () (interactive) (find-file "~/Sites/blog/")))
(global-set-key (kbd "C-c h P") (lambda () (interactive) (find-file "~/Sites/blog/content/post/")))
(global-set-key (kbd "C-c h d") 'hugo-deploy)
(global-set-key (kbd "C-c h g") 'hugo-select-tags)
(global-set-key (kbd "C-c h m") 'hugo-update-lastmod)
#+end_src




* EWW

#+begin_src emacs-lisp :tangle yes
(defun rrnet ()
(interactive)
(eww-browse-url "randyridenour.net")
)

(defun sep ()
(interactive)
(eww-browse-url "plato.stanford.edu")
)
#+end_src

#+RESULTS:
: rrnet


* Keybindings

Unset some keys

#+begin_src emacs-lisp :tangle yes
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "s-p"))
(global-unset-key (kbd "s-d"))
(global-unset-key (kbd "s-m"))
(global-unset-key (kbd "s-n"))
(global-unset-key (kbd "s-h"))
(global-unset-key (kbd "s-w"))
(global-unset-key (kbd "M-;"))
(global-unset-key (kbd "s-/"))
(global-unset-key (kbd "s-/"))
(global-unset-key (kbd "<S-return>"))
#+end_src

#+begin_src emacs-lisp :tangle yes
;;(define-key evil-normal-state-map (kbd "s-/") #'avy-goto-char-timer)
#+end_src


** Hydras

[[https://github.com/jerrypnz/major-mode-hydra.el][Major-mode-hydra]] provides the ability to define a different hydra for each major mode, all accessible using the same keybinding.


#+begin_src emacs-lisp :tangle yes
(use-package! major-mode-hydra
  :defer)
(map! "s-m" #'major-mode-hydra)
#+end_src


*** Doom Dashboard

#+begin_src emacs-lisp :tangle yes
(major-mode-hydra-define dashboard-mode
  (:quit-key "q")
  ("Open"
   (("m" consult-bookmark "bookmarks")
    ("a" consult-org-agenda "consult-agenda")
    ("t" (find-file "/Users/rlridenour/Library/Mobile Documents/iCloud~com~appsonthemove~beorg/Documents/org/tasks.org") "open tasks")
    )))
#+end_src


*** EWW Mode

#+begin_src emacs-lisp :tangle yes
(major-mode-hydra-define eww-mode
  (:quit-key "q")
  ("A"
(
    ("G" eww "Eww Open Browser")
    ("g" eww-reload "Eww Reload")
    ("6" eww-open-in-new-buffer "Open in new buffer")
    ("l" eww-back-url "Back Url")
    ("r" eww-forward-url "Forward Url")
    ("N" eww-next-url "Next Url")
    ("P" eww-previous-url "Previous Url")
    ("u" eww-up-url "Up Url")
    ("&" eww-browse-with-external-browser "Open in External Browser")
    ("d" eww-download "Download")
    ("w" eww-copy-page-url "Copy Url Page")
);end theme
"B"
(
    ("T" endless/toggle-image-display "Toggle Image Display")    
    (">" shr-next-link "Shr Next Link")
    ("<" shr-previous-link "Shr Previous Link")
    ("n" scroll-down-command "Scroll Down")
    ("C" url-cookie-list "Url Cookie List")
    ("v" eww-view-source "View Source")
    ("R" eww-readable "Make Readable")
    ("H" eww-list-histories "List History")
    ("E" eww-set-character-encoding "Character Encoding")
    ("s" eww-switch-to-buffer "Switch to Buffer")
    ("S" eww-list-buffers "List Buffers")
);end highlighting

"C"
(

    ("1" rrnet "randyridenour.net")
    ("2" sep "SEP")
    ("F" eww-toggle-fonts "Toggle Fonts")
    ("D" eww-toggle-paragraph-direction "Toggle Paragraph Direction")
    ("c" eww-toggle-colors "Toggle Colors")
    ("b" eww-add-bookmark "Add Bookmark")
    ("B" eww-list-bookmarks "List Bookmarks")
    ("=" eww-next-bookmark "Next Bookmark")
    ("-" eww-previous-bookmark "Previous Bookmark")
    ("<SPC>" nil "Quit" :color pink)
);end other
))

#+end_src




*** Markdown Mode

#+begin_src emacs-lisp :tangle yes
(major-mode-hydra-define markdown-mode
  (:quit-key "q")
  ("Format"
   (("h" markdown-insert-header-dwim "header")
    ("l" markdown-insert-link "link")
    ("u" markdown-insert-uri "url")
    ("f" markdown-insert-footnote "footnote")
    ("w" markdown-insert-wiki-link "wiki")
    ("r" markdown-insert-reference-link-dwim "r-link")
    ("n" markdown-cleanup-list-numbers "clean-lists")
    ("c" markdown-complete-buffer "complete"))))
#+end_src

*** LaTeX Mode

#+begin_src emacs-lisp :tangle yes
(major-mode-hydra-define latex-mode
  (:quit-key "q")
  ("Bibtex"
   (("r" citar-insert-citation "citation"))
   "LaTeXmk"
   (("m" rlr/tex-mkt "arara")
    ("w" rlr/tex-mktc "arara watch")
    ("c" tex-clean "clean aux")
    ("C" tex-clean-all "clean all")
    ("n" latex-word-count "word count"))))
#+end_src

*** Hydra Org Mode

#+begin_src emacs-lisp :tangle yes
(major-mode-hydra-define org-mode
  (:quit-key "q")
  ("Export"
   (
    ("m" rlr/org-mkt "Make PDF with Arara")
    ("el" org-latex-export-to-latex "Org to LaTeX")
    ("eb" org-beamer-export-to-pdf "Org to Beamer-PDF")
    ("eB" org-beamer-export-to-latex "Org to Beamer-LaTeX")
    ("s" lecture-slides "Lecture slides")
    ("n" lecture-notes "Lecture notes")
    ("ep" present "Present slides")
    ("eh" canvas-copy "Copy html for Canvas")
    ("c" tex-clean "clean aux")
    ("C" tex-clean-all "clean all")
    )
   "Edit"
   (
    ("dd" org-deadline "deadline")
    ("ds" org-schedule "schedule")
    ("r" org-refile "refile")
    ("du" rlr/org-date "update date stamp")
    ;; ("fn" org-footnote-new "insert footnote")
    ("ff" org-footnote-action "edit footnote")
    ("fc" citar-insert-citation "citation")
    ("b" org-cycle-list-bullet "cycle bullets" :exit nil)
    ("l" org-mac-link-safari-insert-frontmost-url "insert safari link")
("y" yankpad-set-category "set yankpad")
    )
   "View"
   (
    ("vi" consult-org-heading "iMenu")
    ("vu" org-toggle-pretty-entities "org-pretty")
    ("vI" org-toggle-inline-images "Inline images")
    )
   "Blog"
   (("hn" hugo-draft-post "New draft")
    ("hp" hugo-publish-post "Publish")
    ("ht" hugo-timestamp "Update timestamp")
    ("hd" hugo-org-deploy "Deploy")
    ("he" org-hugo-auto-export-mode "Auto export"))
   "Notes"
   (("1" denote-link "link to note"))
   ))
#+end_src

#+begin_src emacs-lisp :tangle yes
(major-mode-hydra-define dired-mode
  (:quit-key "q")
  ("Tools"
   (("d" crux-open-with "Open in default program")
    ("h" dired-omit-mode "Show hidden files") 
    ("p" diredp-copy-abs-filenames-as-kill "Copy filename and path")
    ("n" dired-toggle-read-only "edit Filenames"))))
#+end_src


Key-chords

#+begin_src emacs-lisp :tangle yes
(use-package! key-chord
  :init
  (key-chord-mode 1)
  :config
  (key-chord-define-global "kj" #'doom/escape)
  (key-chord-define-global "jk" #'doom/escape)
  )
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun my/insert-unicode (unicode-name)
  "Same as C-x 8 enter UNICODE-NAME."
  (insert-char (gethash unicode-name (ucs-names))))
#+end_src

*** Hydra Toggle

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-toggle
  (:color teal :quit-key "q" :title "Toggle")
  (" "
   (("a" abbrev-mode "abbrev" :toggle t)
    ("d" toggle-debug-on-error "debug" (default value 'debug-on-error))
    ("e" evil-mode "evil" :toggle t)
    ("i" aggressive-indent-mode "indent" :toggle t)
    ("f" auto-fill-mode "fill" :toggle t)
    ("l" display-line-numbers-mode "linum" :toggle t)
    ("m" toggle-frame-maximized-undecorated "max" :toggle t)
    ("p" smartparens-mode "smartparens" :toggle t)
    ("t" toggle-truncate-lines "truncate" :toggle t)
    ("s" whitespace-mode "whitespace" :toggle t))
   " "
   (("c" cdlatex-mode "cdlatex" :toggle t)
    ("h" hyperbole-mode "hyperbole" :toggle t)
    ("z" +zen/toggle "zen" :toggle t)
    ("r" read-only-mode "read-only" :toggle t)
    ("v" view-mode "view" :toggle t)
    ;; ("w" wc-mode "word-count" :toggle t)
    ("S" auto-save-visited-mode "auto-save" :toggle t)
    ("C" cua-selection-mode "rectangle" :toggle t))))
#+end_src

*** Hydra Buffer

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-buffer
  (:color teal :quit-key "q" :title "Buffers and Files")
  ("Open"
   (("b" ibuffer "ibuffer")
    ("m" consult-bookmark "bookmark")
    ("w" consult-buffer-other-window "other window")
    ("f" consult-buffer-other-frame "other frame")
    ("d" crux-recentf-find-directory "recent directory")
    ("a" crux-open-with "open in default app"))
   "Actions"
   (("D" crux-delete-file-and-buffer "delete file")
    ("R" crux-rename-file-and-buffer "rename file")
    ("K" crux-kill-other-buffers "kill other buffers")
    ("N" nuke-all-buffers "Kill all buffers")
    ("c" crux-cleanup-buffer-or-region "fix indentation"))
   "Misc"
   (("t" crux-visit-term-buffer "ansi-term")
    ("T" +macos/open-in-iterm "iTerm2")
    ("i" crux-find-user-init-file "init.el")
    ("s" crux-find-shell-init-file "fish config"))
   ))
#+end_src

#+RESULTS:
: hydra-buffer/body

*** Hydra locate

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-locate
  (:color teal :quit-key "q" title: "Search")
  ("Buffer"
   (("c" pulsar-highlight-dwim "find cursor")
    ("l" consult-goto-line "goto-line")
    ("i" consult-imenu "imenu")
    ("m" consult-mark "mark")
    ("o" consult-outline "outline"))
   "Global"
   (("M" consult-global-mark "global-mark")
    ("n" consult-notes "notes")
    ("r" consult-ripgrep "ripgrep"))
   ))
#+end_src

*** Hydra Window

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-window
  (:color teal :quit-key "q" title: "Windows")
  ("Windows"
   (("w" other-window "cycle windows" :exit nil)
    ("a" ace-window "ace window")
    ("m" minimize-window "minimize window")
    ("s" transpose-windows "swap windows")
    ("S" shrink-window-if-larger-than-buffer "shrink to fit")
    ("b" balance-windows "balance windows")
    ("t" toggle-window-split "toggle split")
    ("T" enlarge-window" grow taller" :exit nil)
    ("G" enlarge-window-horizontally "grow wider" :exit nil)
    ("o" delete-other-windows "other windows"))
   "Frames"
   (("M" iconify-frame "minimize frame")
    ("d" delete-other-frames "delete other frames")
    ("D" delete-frame "delete this frame")
    ("i" make-frame-invisible "invisible frame")
    ("f" toggle-frame-fullscreen "fullscreen")
    ("n" make-frame-command "new frame")
    )))
#+end_src


*** Hydra New

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-new
(:color teal :quit-key "q" title: "New")
("Denote"
(("b" hugo-draft-post "blog post")
("c" org-capture "capture")
("n" denote-create-note "note")
("v" list-denotes "view notes")
("j" my-denote-journal "journal"))
))
#+end_src
*** Hydra Logic

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-logic
  (:color pink :quit-key "0" :title "Logic")
  ("Operators"
   (("-" (my/insert-unicode "NOT SIGN") "¬")
    ("&" (my/insert-unicode "AMPERSAND") "&")
    ("v" (my/insert-unicode "LOGICAL OR") "v")
    (">" (my/insert-unicode "SUPERSET OF") "⊃")
    ("<" (my/insert-unicode "IDENTICAL TO") "≡")
    ;; (">" (my/insert-unicode "RIGHTWARDS ARROW") "→")
    ;; ("<" (my/insert-unicode "LEFT RIGHT ARROW") "↔")
    ("1" (my/insert-unicode "THERE EXISTS") "∃")
    ("2" (my/insert-unicode "FOR ALL") "∀")
    ("3" (my/insert-unicode "WHITE MEDIUM SQUARE") "□")
    ("4" (my/insert-unicode "LOZENGE") "◊")
    ("5" (my/insert-unicode "TRUE") "⊨")
    ("6" (my/insert-unicode "NOT TRUE") "⊭")
)
   "Space"
   (("?" (my/insert-unicode "MEDIUM MATHEMATICAL SPACE") "Narrow space"))
   "Quit"
   (("0" quit-window "quit" :color blue))
   ))
#+end_src

*** Hydra Math

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-math
  (:color pink :quit-key "?" :title "Math")
  ("Operators"
   (("1" (my/insert-unicode "NOT SIGN") "¬")
    ("2" (my/insert-unicode "AMPERSAND") "&")
    ("3" (my/insert-unicode "LOGICAL OR") "v")
    ("4" (my/insert-unicode "RIGHTWARDS ARROW") "→")
    ("5" (my/insert-unicode "LEFT RIGHT ARROW") "↔")
    ("6" (my/insert-unicode "THERE EXISTS") "∃")
    ("7" (my/insert-unicode "FOR ALL") "∀")
    ("8" (my/insert-unicode "WHITE MEDIUM SQUARE") "□")
    ("9" (my/insert-unicode "LOZENGE") "◊"))
   "Sets"
   (("R" (my/insert-unicode "DOUBLE-STRUCK CAPITAL R") "ℝ real")
    ("N" (my/insert-unicode "DOUBLE-STRUCK CAPITAL N") "ℕ natural")
    ("Z" (my/insert-unicode "DOUBLE-STRUCK CAPITAL Z") "ℤ integer")
    ("Q" (my/insert-unicode "DOUBLE-STRUCK CAPITAL Q") "ℚ rational")
    ("Q" (my/insert-unicode "DOUBLE-STRUCK CAPITAL Q") "ℚ rational")
    ("Q" (my/insert-unicode "DOUBLE-STRUCK CAPITAL Q") "ℚ rational")
    )
   "Space"
   (("?" (my/insert-unicode "MEDIUM MATHEMATICAL SPACE") "Narrow space"))
   "Quit"
   (("?" quit-window "quit" :color blue))
   ))
#+end_src

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-hugo
  (:color teal :quit-key "q" :title "Hugo")
  ("Blog"
   (("n" hugo-draft-post "New draft")
    ("p" hugo-publish-post "Publish")
    ("t" hugo-timestamp "Update timestamp")
    ("e" org-hugo-auto-export-mode "Auto export")
    ("d" hugo-deploy "Deploy"))
   ))
#+end_src

*** Hydra Hydras

#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-hydras
  (:color teal :quit-key "q" :title "Hydras")
  ("System"
   (("t" hydra-toggle/body)
    ("h" hydra-hugo/body))
   "Unicode"
   (("l" hydra-logic/body "logic")
    ("m" hydra-math/body)
    )
   )
  )
#+end_src



** Misc Keybindings

#+begin_src emacs-lisp :tangle yes
;; (global-set-key [remap zap-to-char] 'zop-to-char)
(map!
 "<s-up>" #'beginning-of-buffer
 "<s-down>" #'end-of-buffer
 "<s-right>" #'end-of-visual-line
 "<s-left>" #'beginning-of-visual-line
 "s-w" #'delete-frame
 "<C-tab>" #'other-window
 "<M-down>" #'forward-paragraph
 "<M-up>" #'backward-paragraph

 ;; Windows and frames
 "C-0" #'delete-window-balance
 "C-1" #'delete-other-windows
 "C-2" #'evil-window-split
 "C-3" #'evil-window-vsplit
 "s-K" #'nuke-all-buffers
 "s-6" #'toggle-window-split
 "S-C-<left>" #'shrink-window-horizontally
 "S-C-<right>" #'enlarge-window-horizontally
 "S-C-<down>" #'shrink-window
 "S-C-<up>" #'enlarge-window
 "C-x w" #'delete-frame
 "M-o" #'crux-other-window-or-switch-buffer
 ;; "s-n" #'make-frame-command

 ;; Files and buffers
 "C-x c" #'save-buffers-kill-emacs
 "C-x C-b" #'ibuffer
 "C-`" #'+macos/open-in-iterm
 "s-o" #'find-file
 "s-k" #'kill-this-buffer
"M-s-k" #'kill-buffer-and-window
 "s-r" #'consult-buffer
 "M-s-r" #'consult-buffer-other-window
 "C-S-a" #'embark-act
 "<f12>" #'+term/toggle

 ;; Search

 "s-l" #'hydra-locate/body
 "s-f" #'consult-line
 ;; "C-s" #'consult-isearch
 ;; "C-r" #'consult-isearch-reverse

 ;; Editing
 "RET" #'newline-and-indent
 "M-/" #'hippie-expand
 "C-+" #'text-scale-increase
 "C--" #'text-scale-decrease
 "<s-backspace>" #'kill-whole-line
 "s-j" #'crux-top-join-line
 "<S-return>" #'crux-smart-open-line
 "<C-S-return>" #'crux-smart-open-line-above
 "M-y" #'consult-yank-pop
 "M-q" #'reformat-paragraph
 "M-;" #'evilnc-comment-or-uncomment-lines
 "M-#" #'dictionary-lookup-definition

 ;; Hydras
 "s-h" #'hydra-hydras/body
 "s-n" #'hydra-new/body
 "s-t" #'hydra-toggle/body
 "s-w" #'hydra-window/body
 "s-b" #'hydra-buffer/body
 "C-x 9" #'hydra-logic/body

 "s-/" #'avy-goto-char-timer
 ;; "s-d" #'dirvish
 "s-d" #'goto-dashboard
 ;; "s-=" #'endless/ispell-word-then-abbrev
 "<help> a" #'consult-apropos
 "C-x 4 b" #'consult-buffer-other-window
 "C-x 5 b" #'consult-buffer-other-frame
 "C-x r x" #'consult-register
 "M-s m" #'consult-multi-occur
 "<f8>" #'insert-standard-date
;; "<f7>" #'ispell-word-immediate-forward
 "M-u" #'upcase-dwim
 "M-l" #'downcase-dwim
 "M-c" #'capitalize-dwim


 ;; "C-c u" #'unfill-paragraph
 ;; "C-c C-<return>" #'split-org-item
 ;; "C-c o" #'crux-open-with
 ;; "C-c D" #'crux-delete-file-and-buffer
 ;; "C-c C-k" #'compile



 ;; Prefix Keybindings
 ;; :prefix can be used to prevent redundant specification of prefix keys
 ;; bind "C-c a" to #'org-agenda
 "C-c a" #'org-agenda
 "C-c 2" #'rlr/find-file-below
 "C-c 3" #'rlr/find-file-right
 "C-c b" #'consult-bookmark
 ;; "C-c h" #'consult-history
 "C-c k" #'crux-kill-other-buffers
 "C-c m" #'consult-mark
 "C-c n b" #'hugo-draft-post
 "C-c n d" #'denote
 "C-c n j" #'my-denote-journal
 "C-c o" #'consult-outline
 "C-c s" #'goto-scratch
 "C-c S" #'crux-cleanup-buffer-or-region
 "C-c t" #'crux-visit-term-buffer
 "C-c u" #'unfill-paragraph
 "C-c w" #'ace-window
 "C-c z" #'+macos/reveal-in-finder
 )
#+end_src



* Final Steps

#+begin_src emacs-lisp :tangle yes
(setq default-directory "~/")
#+end_src
